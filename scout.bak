#!/usr/bin/env bash
set -euo pipefail
IFS=$' \t\n'

# ---------------- COLORS ----------------
BLUE="\e[94m"; GREEN="\e[92m"; YELLOW="\e[93m"; RED="\e[91m"; RESET="\e[0m"; BOLD="\e[1m"; CYAN="\033[0;36m"; HIGH_GREEN="\e[38;5;82m"

# ---------------- LOGGING ----------------
OK()   { printf "${GREEN}[✓] %s${RESET}\n" "$1"; }
INFO() { printf "${BLUE}[*] %s${RESET}\n" "$1"; }
WARN() { printf "${YELLOW}[!] %s${RESET}\n" "$1"; }
ERR()  { printf "${RED}[X] %s${RESET}\n" "$1" >&2; }

# ---------------- DEFAULT PATHS & SETTINGS ----------------
VER="v0.1"
INSTALL_DIR="${HOME}/scout"
TOOLS_DIR="${INSTALL_DIR}/tools"
BIN_DIR="${TOOLS_DIR}/bin"
WORDLISTS_DIR="${TOOLS_DIR}/wordlists"
WORKSPACE_DIR="${INSTALL_DIR}/workspace"

# scanner rate/delay defaults (conservative)
NAABU_RATE=150
MASSCAN_RATE=300
NMAP_TPS=50
FFUF_CONCURRENCY=50
FFUF_WORDLISTS=(
  "/usr/share/wordlists/dirb/common.txt"
  "/usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt"
  "/usr/share/wordlists/raft-large-directories.txt"
  "/usr/share/wordlists/ffuf/wordlist.txt"
)

# ---------------- ARGS ----------------
INPUT_DOMAIN=""
INPUT_DOMAIN_FILE=""
INPUT_WILDCARD=""
INPUT_WILDCARD_FILE=""
CUSTOM_OUTPUT=""

# ---------------- BANNER ----------------
BANNER(){
  ASCII_SCOUT=$(cat <<'EOF'
    /$$$$$$   /$$$$$$   /$$$$$$  /$$   /$$ /$$$$$$$$
   /$$__  $$ /$$__  $$ /$$__  $$| $$  | $$|__  $$__/
  | $$  \__/| $$  \__/| $$  | $$| $$  | $$   | $$
  |  $$$$$$ | $$      | $$  | $$| $$  | $$   | $$
   \____  $$| $$      | $$  | $$| $$  | $$   | $$
   /$$  \ $$| $$    $$| $$  | $$| $$  | $$   | $$
  |  $$$$$$/|  $$$$$$/|  $$$$$$/|  $$$$$$/   | $$
   \______/  \______/  \______/  \______/    |__/
EOF
  )
  TAGLINE="Recon Made Easy                  Made By Ghost ${VER}"
  echo -e "${BOLD}${GREEN}=====================================================${RESET}"

  while IFS= read -r LINE; do
    for ((i=0;i<${#LINE};i++)); do
      printf "${HIGH_GREEN}${BOLD}%c${RESET}" "${LINE:i:1}"
      sleep 0.0005
    done
    printf "\n"
  done <<< "$ASCII_SCOUT"

  for ((i=0;i<${#TAGLINE};i++)); do
    printf "${CYAN}${BOLD}%c${RESET}" "${TAGLINE:i:1}"
    sleep 0.001
  done
  printf "\n"
  echo -e "${BOLD}${GREEN}=====================================================${RESET}"
}

# ---------------- REQUIRE ROOT ----------------
REQUIRE_ROOT() {
  if (( EUID != 0 )); then
    echo -e "${RED}[X] Root privileges required.${RESET}"
    echo -e "${YELLOW}[*] Re-running with sudo...${RESET}\n"
    exec sudo -E bash "$0" "$@"  # Preserve env and args
  fi
}

# ---------------- HELP ----------------
USAGE() {
  cat <<EOF
Usage: scout [options]
You can provide single or multiple comma-separated values for -dt and -wd:
  -dd   <domain.com[domain1.com,domain2.com,...]>      One or more domains
  -df   <file>                                         File with one domain per line
  -wd   <*.domain.com[*.domain.com,*.domain2.com,...]>            One or more wildcard domains
  -wc | -wf <file>                                     File with one wildcard per line

Optional:
  -o <dir>                                  Custom output directory (under $WORKSPACE_DIR)

Examples:
  scout -dd example.com
  scout -dd ex1.com,ex2.com -wd '*.ex.com,*.ex2.com'
  scout -df domains.txt -wf wildcards.txt
  scout -dd example.com -o myout

Flags:
  -h, --help        Show this help
  -v, --version     Show version information
EOF
  exit 0
}
BANNER
REQUIRE_ROOT "$@"

# ---------------- ARGUMENT PARSING ----------------
if [[ $# -eq 0 ]]; then
  ERR "No arguments provided."
  USAGE
fi

while [[ $# -gt 0 ]]; do
  case "$1" in
    -dd)
      [[ -z "${2:-}" || "${2:0:1}" == "-" ]] && { ERR "Option -dt requires argument(s)."; USAGE; }
      INPUT_DOMAIN="$2"; shift 2;;
    -df)
      [[ -z "${2:-}" || "${2:0:1}" == "-" ]] && { ERR "Option -df requires a file path."; USAGE; }
      INPUT_DOMAIN_FILE="$2"; shift 2;;
    -wd)
      [[ -z "${2:-}" || "${2:0:1}" == "-" ]] && { ERR "Option -wd requires argument(s)."; USAGE; }
      INPUT_WILDCARD="$2"; shift 2;;
    -wf)
      [[ -z "${2:-}" || "${2:0:1}" == "-" ]] && { ERR "Option $1 requires a file path."; USAGE; }
      INPUT_WILDCARD_FILE="$2"; shift 2;;
    -o)
      [[ -z "${2:-}" || "${2:0:1}" == "-" ]] && { ERR "Option -o requires a directory name."; USAGE; }
      CUSTOM_OUTPUT="$2"; shift 2;;
    -h|--help) USAGE ;;
    -v|--version)
      echo -e "${BOLD}Version:${RESET} ${VER}"
      exit 0;;
    *)
      ERR "Unknown option: $1"
      USAGE;;
  esac
done

# ---------------- OUTPUT DIR ----------------
CURRENTDATE=$(date +"%Y-%m-%d_%H-%M-%S")
if [[ -n "$CUSTOM_OUTPUT" ]]; then
  SANITIZED_OUTPUT=$(echo "$CUSTOM_OUTPUT" | tr -cd '[:alnum:]_-')
  OUTPUT_DIR="$WORKSPACE_DIR/$SANITIZED_OUTPUT"
else
  OUTPUT_DIR="$WORKSPACE_DIR/output_$CURRENTDATE"
fi
mkdir -p "$OUTPUT_DIR"

# ---------------- SPINNER & CLEANUP ----------------
CLEANUP() {
  if [[ -n "${SPINNER_PID:-}" ]]; then
    kill "$SPINNER_PID" 2>/dev/null || true
  fi
  echo -ne "\r\033[K"
}
trap CLEANUP SIGINT SIGTERM EXIT

START_SPINNER() {
  processing="$1"
  SPIN_START=$(date +%s)
  BRAILLE=("⠋" "⠙" "⠹" "⠸" "⠼" "⠴" "⠦" "⠧" "⠇" "⠏")
  while true; do
    ELAPSED=$(( $(date +%s) - SPIN_START ))
    for char in "${BRAILLE[@]}"; do
      printf "\r${YELLOW}[${char}]${RESET} ${processing} ${CYAN}(${ELAPSED}s)${RESET}"
      sleep 0.07
    done
  done &
  SPINNER_PID=$!
}

STOP_SPINNER() {
  if [[ -n "${SPINNER_PID:-}" ]]; then
    kill "$SPINNER_PID" 2>/dev/null || true
    wait "$SPINNER_PID" 2>/dev/null || true
    echo -ne "\r\033[K"
  fi
}

# ---------------- BASIC CHECKS ----------------
CHECK_INTERNET(){
  INFO "Checking internet connectivity..."
  if ! curl -fsS --head https://www.google.com >/dev/null 2>&1; then
    if ! ping -c1 1.1.1.1 >/dev/null 2>&1; then
      ERR "No Internet connection detected."; exit 1
    fi
  fi
  OK "Online"
}

CHECK_BINS(){
  REQUIRED=(subfinder assetfinder findomain gau waybackurls amass httpx unfurl dnsx ffuf nuclei naabu)
  MISSING=()
  for b in "${REQUIRED[@]}"; do
    if ! command -v "$b" >/dev/null 2>&1 && [[ ! -x "$BIN_DIR/$b" ]]; then
      MISSING+=("$b")
    fi
  done
  if (( ${#MISSING[@]} > 0 )); then
    ERR "Missing tools: ${MISSING[*]}"
    exit 1
  fi
  OK "All required tools found"
}

PICK_WORDLIST(){
  for w in "${FFUF_WORDLISTS[@]}"; do
    [[ -f "$w" ]] && { echo "$w"; return; }
  done
  echo ""
}

# ---------------- INPUT VALIDATION ----------------
if [[ -z "$INPUT_DOMAIN" && -z "$INPUT_DOMAIN_FILE" && -z "$INPUT_WILDCARD" && -z "$INPUT_WILDCARD_FILE" ]]; then
  ERR "No input provided. Use -dt, -df, -wd, or -wc/-wf."
  USAGE
fi

# ---------------- BUILD TARGETS ----------------
TARGETS_FILE="$OUTPUT_DIR/targets.txt"
: > "$TARGETS_FILE"  # create/empty file

# helper: trim whitespace
_trim(){ local v="$*"; v="${v#"${v%%[![:space:]]*}"}"; v="${v%"${v##*[![:space:]]}"}"; printf '%s' "$v"; }

# 1) domains passed directly via -dt (comma separated allowed)
if [[ -n "$INPUT_DOMAIN" ]]; then
  IFS=',' read -ra D_ARR <<< "$INPUT_DOMAIN"
  for d in "${D_ARR[@]}"; do
    d=$(_trim "$d")
    [[ -n "$d" ]] && printf '%s\n' "$d" >> "$TARGETS_FILE"
  done
fi

# 2) domain file -df
if [[ -n "$INPUT_DOMAIN_FILE" ]]; then
  [[ ! -r "$INPUT_DOMAIN_FILE" ]] && { ERR "Cannot read domain file: $INPUT_DOMAIN_FILE"; exit 1; }
  awk 'NF && $1 !~ /^#/' "$INPUT_DOMAIN_FILE" >> "$TARGETS_FILE"
fi

# 3) wildcard(s) via -wd (comma separated allowed)
if [[ -n "$INPUT_WILDCARD" ]]; then
  IFS=',' read -ra W_ARR <<< "$INPUT_WILDCARD"
  for w in "${W_ARR[@]}"; do
    w=$(_trim "$w")
    [[ -n "$w" ]] && printf '%s\n' "$w" >> "$TARGETS_FILE"
  done
fi

# 4) wildcard file -wc or -wf
if [[ -n "$INPUT_WILDCARD_FILE" ]]; then
  [[ ! -r "$INPUT_WILDCARD_FILE" ]] && { ERR "Cannot read wildcard file: $INPUT_WILDCARD_FILE"; exit 1; }
  awk 'NF && $1 !~ /^#/' "$INPUT_WILDCARD_FILE" >> "$TARGETS_FILE"
fi

# remove duplicates while preserving order
awk '!seen[$0]++' "$TARGETS_FILE" > "${TARGETS_FILE}.uniq" && mv "${TARGETS_FILE}.uniq" "$TARGETS_FILE"

# ---------------- SUMMARY ----------------
SCAN_MODE="Mixed"
echo -e "${BOLD}${CYAN}"
echo "─────────────────────────── SCOUT RUN SUMMARY ───────────────────────────"
echo -e "${RESET}${BOLD}Mode:${RESET} ${SCAN_MODE}"
echo -e "${BOLD}Targets:${RESET}"
head -n 10 "$TARGETS_FILE" || true
TOTAL=$(wc -l < "$TARGETS_FILE" || echo 0)
(( TOTAL > 10 )) && echo "  ... +$((TOTAL - 10)) more"
echo -e "${BOLD}Output Directory:${RESET} $OUTPUT_DIR"
echo -e "${BOLD}Tools Used:${RESET}"
cat <<'EOF'
  • Subdomain enumeration: subfinder, assetfinder, findomain, amass, gau, waybackurls
  • Live host discovery: dnsx
  • Port scanning: naabu, masscan
  • Service detection: nmap
  • Directory fuzzing: ffuf
  • Vulnerability scanning: nuclei
EOF
echo -e "${BOLD}${CYAN}──────────────────────────────────────────────────────────────────────────${RESET}\n"
sleep 1

# ---------------- STUB FUNCTIONS ----------------
# These are basic stubs that simulate behavior and create minimal placeholder outputs.
# Replace their internals with real implementations or source external scripts as you build them.

COLLECT_SUBDOMAINS(){
  # args: domain, domain_output_dir
  local domain="${1:-}"
  local outdir="${2:-}"
  INFO "COLLECT_SUBDOMAINS: enumerating subdomains for ${domain} (stub)"
  mkdir -p "${outdir}/raw" "${outdir}/collected"
  # create a placeholder subdomains file
  echo "www.${domain}" > "${outdir}/raw/all_subdomains.out"
  echo "www.${domain}" > "${outdir}/collected/all_subdomains.txt"
  OK "COLLECT_SUBDOMAINS: created placeholder subdomain files in ${outdir}"
}

COLLECT_LIVE(){
  # args: domain, domain_output_dir
  local domain="${1:-}"
  local outdir="${2:-}"
  INFO "COLLECT_LIVE: resolving live hosts for ${domain} (stub)"
  mkdir -p "${outdir}/collected"
  # create a placeholder hosts list containing a dummy host (so downstream steps run)
  # For wildcard entries we keep the host as-is; for normal domains we produce host "www.domain"
  if [[ "$domain" == \** ]]; then
    # wildcard - write the wildcard without modification
    echo "${domain}" > "${outdir}/collected/hosts.txt"
  else
    echo "www.${domain}" > "${outdir}/collected/hosts.txt"
  fi
  OK "COLLECT_LIVE: wrote placeholder hosts to ${outdir}/collected/hosts.txt"
}

PORT_SCAN_PER_HOST(){
  # args: host, domain_output_dir
  local host="${1:-}"
  local outdir="${2:-}"
  INFO "PORT_SCAN_PER_HOST: scanning ${host} (stub - not performing real scan)"
  mkdir -p "${outdir}/raw/ports" "${outdir}/collected/ports"
  echo "80,443" > "${outdir}/collected/ports/${host}.ports"
  OK "PORT_SCAN_PER_HOST: created placeholder ports file for ${host}"
}

SERVICE_DETECT_NMAP(){
  # args: host, domain_output_dir
  local host="${1:-}"
  local outdir="${2:-}"
  INFO "SERVICE_DETECT_NMAP: detecting services on ${host} (stub)"
  mkdir -p "${outdir}/raw/nmap" "${outdir}/collected/nmap"
  echo "http (80) - placeholder" > "${outdir}/collected/nmap/${host}.nmap"
  OK "SERVICE_DETECT_NMAP: created placeholder nmap output for ${host}"
}

RUN_FFUF_AND_NUCLEI_PER_HOST(){
  # args: host, domain_output_dir
  local host="${1:-}"
  local outdir="${2:-}"
  INFO "RUN_FFUF_AND_NUCLEI_PER_HOST: fuzzing and running nuclei on ${host} (stub)"
  mkdir -p "${outdir}/raw/ffuf" "${outdir}/collected/ffuf" "${outdir}/raw/nuclei" "${outdir}/collected/nuclei"
  echo "/login" > "${outdir}/collected/ffuf/${host}.paths"
  echo "nuclei: no findings (placeholder)" > "${outdir}/collected/nuclei/${host}.nuclei"
  OK "RUN_FFUF_AND_NUCLEI_PER_HOST: created placeholder ffuf/nuclei outputs for ${host}"
}

# ---------------- MAIN EXECUTION ----------------
INFO "Starting SCOUT"
INFO "Output directory: $OUTPUT_DIR"
CHECK_INTERNET
CHECK_BINS || true  # allow stubs to run even if tools not locally installed (remove || true in prod)

while read -r DOMAIN; do
  DOMAIN=$(echo "$DOMAIN" | tr -d '[:space:]')
  [[ -z "$DOMAIN" ]] && continue

  # Build safe per-domain directory name: replace '*' with 'WILDCARD' and strip slashes
  SAFE_NAME="${DOMAIN//\*/WILDCARD}"
  SAFE_NAME="${SAFE_NAME//\//_}"
  DOMAIN_OUTPUT_DIR="$OUTPUT_DIR/${SAFE_NAME}"
  mkdir -p "$DOMAIN_OUTPUT_DIR/raw" "$DOMAIN_OUTPUT_DIR/collected"

  INFO "Processing target: $DOMAIN"

  COLLECT_SUBDOMAINS "$DOMAIN" "$DOMAIN_OUTPUT_DIR"
  COLLECT_LIVE "$DOMAIN" "$DOMAIN_OUTPUT_DIR"

  HOSTS_FILE="$DOMAIN_OUTPUT_DIR/collected/hosts.txt"
  if [[ ! -s "$HOSTS_FILE" ]]; then
    WARN "No live hosts found for $DOMAIN; skipping host scans."
    continue
  fi

  while read -r HOST; do
    HOST=$(echo "$HOST" | tr -d '[:space:]')
    [[ -z "$HOST" ]] && continue
    INFO "Processing host: $HOST"
    PORT_SCAN_PER_HOST "$HOST" "$DOMAIN_OUTPUT_DIR"
    SERVICE_DETECT_NMAP "$HOST" "$DOMAIN_OUTPUT_DIR"
    RUN_FFUF_AND_NUCLEI_PER_HOST "$HOST" "$DOMAIN_OUTPUT_DIR"
  done < "$HOSTS_FILE"

  OK "Target $DOMAIN finished. Outputs under $DOMAIN_OUTPUT_DIR"
done < "$TARGETS_FILE"

OK "All done. Outputs are in: $OUTPUT_DIR"
# EOF