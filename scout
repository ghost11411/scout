#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'

# ---------------- COLORS ----------------
BLUE="\e[94m"; GREEN="\e[92m"; YELLOW="\e[93m"; RED="\e[91m"; RESET="\e[0m"; BOLD="\e[1m"; CYAN="\033[0;36m"; HIGH_GREEN="\e[38;5;82m"

# ---------------- LOGGING ----------------
OK()   { printf "${GREEN}[✔] %s${RESET}\n" "$1"; }
INFO() { printf "${BLUE}[i] %s${RESET}\n" "$1"; }
ERR()  { printf "${RED}[✘] %s${RESET}\n" "$1"; }

# ---------------- CHECK ROOT ----------------
CHECK_ROOT(){
  if [ "$EUID" -ne 0 ]; then
  ERR "Please run as root"
  exit 1
fi
}

# ---------------- DEFAULT PATHS & SETTINGS ----------------
VER="v0.1"
INSTALL_DIR="${HOME}/scout"
TOOLS_DIR="${INSTALL_DIR}/tools"
BIN_DIR="${TOOLS_DIR}/bin"
WORDLISTS_DIR="${TOOLS_DIR}/wordlists"
WORKSPACE_DIR="${INSTALL_DIR}/workspace"
LOG_FILE="/tmp/scout_install_failed.log"
: > "$LOG_FILE"

DEBUG=0

# scanner rate/delay defaults (conservative)
NAABU_RATE=150
MASSCAN_RATE=300
NMAP_TPS=50
FFUF_CONCURRENCY=50
FFUF_WORDLISTS=( \
  "/usr/share/wordlists/dirb/common.txt" \
  "/usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt" \
  "/usr/share/wordlists/raft-large-directories.txt" \
  "/usr/share/wordlists/ffuf/wordlist.txt" \
)

# ---------------- ARGS ----------------
ALL_MODE=0
INPUT_DOMAIN=""
INPUT_FILE=""
CUSTOM_OUTPUT=""

source "$INSTALL_DIR/modules/functions" 2>/dev/null || true

# ---------------- ASCII BANNER ----------------
BANNER(){
  ASCII_SCOUT=$(cat <<'EOF'
    /$$$$$$   /$$$$$$   /$$$$$$  /$$   /$$ /$$$$$$$$
   /$$__  $$ /$$__  $$ /$$__  $$| $$  | $$|__  $$__/
  | $$  \__/| $$  \__/| $$  | $$| $$  | $$   | $$
  |  $$$$$$ | $$      | $$  | $$| $$  | $$   | $$
   \____  $$| $$      | $$  | $$| $$  | $$   | $$
   /$$  \ $$| $$    $$| $$  | $$| $$  | $$   | $$
  |  $$$$$$/|  $$$$$$/|  $$$$$$/|  $$$$$$/   | $$
   \______/  \______/  \______/  \______/    |__/
EOF
  )
  TAGLINE="Recon Made Easy                  Made By Ghost ${VER}"
  echo -e "${BOLD}${GREEN}=====================================================${RESET}"

  # Animate ASCII letters line by line
  while IFS= read -r LINE; do
    for ((i=0;i<${#LINE};i++)); do
      printf "${HIGH_GREEN}${BOLD}%c${RESET}" "${LINE:i:1}"
      sleep 0.0005
    done
    printf "\n"
  done <<< "$ASCII_SCOUT"

  # Animate tagline
  for ((i=0;i<${#TAGLINE};i++)); do
    printf "${CYAN}${BOLD}%c${RESET}" "${TAGLINE:i:1}"
    sleep 0.001
  done
  printf "\n"
  echo -e "${BOLD}${GREEN}=====================================================${RESET}"
}

USAGE() {
  cat <<EOF
Usage:
  ./scout.sh -d target.com
  ./scout.sh -f domains.txt
Options:
  -d <domain>           Scan single wildcard domain
  -f <file>             File: wildcard domains (one domain per line)
  -o <dir>              Custom output dir (under $WORKSPACE_DIR)
  --debug               Enable debug output (show raw tool outputs)
  -h, --help            Show this help
EOF
  exit 0
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    -d)
      # require an argument that is not another flag
      if [[ -z "${2:-}" || "${2:0:1}" == "-" ]]; then
        BANNER
        ERR "Option -d requires a domain argument."
        USAGE
      fi
      INPUT_DOMAIN="$2"; shift 2
      ;;
    -f)
      # require an argument that is not another flag
      if [[ -z "${2:-}" || "${2:0:1}" == "-" ]]; then
        BANNER
        ERR "Option -f requires a file path argument."
        USAGE
      fi
      INPUT_FILE="$2"; shift 2
      ;;
    -o)
      if [[ -z "${2:-}" || "${2:0:1}" == "-" ]]; then
        BANNER
        ERR "Option -o requires a directory name."
        USAGE
      fi
      CUSTOM_OUTPUT="$2"; shift 2
      ;;
    --debug) DEBUG=1; shift ;;
    -h|--help) BANNER; USAGE ;;
    *)
      ERR "Unknown option: $1"
      USAGE
      ;;
  esac
done

# ---------------- OUTPUT DIR ----------------
CURRENTDATE=$(date +"%Y-%m-%d_%H-%M-%S")
if [[ -n "$CUSTOM_OUTPUT" ]]; then
  OUTPUT_DIR="$WORKSPACE_DIR/$CUSTOM_OUTPUT"
else
  OUTPUT_DIR="$WORKSPACE_DIR/output_$CURRENTDATE"
fi
mkdir -p "$OUTPUT_DIR"

# ---------------- SPINNER ----------------
START_SPINNER(){
  local MSG="$1"
  (
    local i=0; local chars=(⠋ ⠙ ⠹ ⠸ ⠼ ⠴ ⠦ ⠧ ⠇ ⠏)
    while true; do
      printf "\r\033[K${YELLOW}[${chars[i]}] ${BOLD}${MSG}${RESET}"
      i=$(((i + 1) % ${#chars[@]}))
      sleep 0.1
    done
  ) &
  SPINNER_PID=$!
}
STOP_SPINNER(){
  [[ -n "${SPINNER_PID:-}" ]] && kill "$SPINNER_PID" >/dev/null 2>&1 || true
  wait "$SPINNER_PID" 2>/dev/null || true
  printf "\r\033[K"
}

# ---------------- SAFE TOOL RUNNER ----------------
RUN_TOOL(){
  local NAME="$1"; shift
  local CMD=("$@")
  START_SPINNER "Running ${NAME}"
  if [[ $DEBUG -eq 1 ]]; then
    "${CMD[@]}"
  else
    "${CMD[@]}" > /dev/null 2>&1 || true
  fi
  local STATUS=$?
  STOP_SPINNER
  if [[ $STATUS -eq 0 ]]; then
    printf "${BOLD}${GREEN}[✔] %s completed${RESET}\n" "$NAME"
  else
    printf "${BOLD}${RED}[✗] %s failed${RESET}\n" "$NAME"
  fi
}

# ---------------- BASIC CHECKS ----------------
CHECK_INTERNET(){
  INFO "Checking internet..."
  curl -fsS --head https://www.google.com >/dev/null || { ERR "No Internet"; exit 1; }
  OK "Online"
}

CHECK_BINS(){
  REQUIRED=(subfinder assetfinder findomain gau waybackurls amass httpx unfurl dnsx ffuf nuclei naabu)
  MISSING=()
  for b in "${REQUIRED[@]}"; do
    if ! command -v "$b" >/dev/null 2>&1 && ! command -v "$BIN_DIR/$b" >/dev/null 2>&1; then
      MISSING+=("$b")
    fi
  done
  if [ ${#MISSING[@]} -gt 0 ]; then
    ERR "Missing: ${MISSING[*]}"
    exit 1
  fi
  OK "All tools found"
}

PICK_WORDLIST(){
  for w in "${FFUF_WORDLISTS[@]}"; do
    [[ -f "$w" ]] && { echo "$w"; return; }
  done
  echo ""
}

# ---------------- SUBDOMAIN COLLECTION ----------------
COLLECT_SUBDOMAINS(){
  mkdir -p "$RAW_DIR"
  while read -r domain; do
    domain=$(echo "$domain" | tr -d '[:space:]')
    [ -z "$domain" ] && continue
    INFO "Collecting subdomains for $domain"
    mkdir -p "$RAW_DIR/$domain"
    RUN_TOOL "subfinder" "$BIN_DIR/subfinder" -d "$domain" -all -o "$RAW_DIR/$domain/subfinder.out"
    RUN_TOOL "assetfinder" "$BIN_DIR/assetfinder" "$domain" ">" "$RAW_DIR/$domain/assetfinder.out"
    RUN_TOOL "findomain" "$BIN_DIR/findomain" -t "$domain" --quiet -u "$RAW_DIR/$domain/findomain.out"
    RUN_TOOL "gau" "$BIN_DIR/gau" "$domain" | "$BIN_DIR/unfurl" domain | sort -u > "$RAW_DIR/$domain/gau.out"
    RUN_TOOL "waybackurls" "$BIN_DIR/waybackurls" "$domain" | "$BIN_DIR/unfurl" domain > "$RAW_DIR/$domain/wayback.out"
    RUN_TOOL "amass" "$BIN_DIR/amass" enum -d "$domain" -o "$RAW_DIR/$domain/amass.out"
  done < "$WILDCARDS"

  # after all tools finished for all domains, combine into single file
  ALL_SUBS_FILE="$RAW_DIR/all_subdomains.out"
  > "$ALL_SUBS_FILE"
  for d in "$RAW_DIR"/*; do
    [[ -d "$d" ]] || continue
    cat "$d"/*.out 2>/dev/null || true
  done | $(command -v unfurl || echo "$BIN_DIR/unfurl") domain 2>/dev/null | sort -u > "$ALL_SUBS_FILE" || true
  OK "Collected all subdomains -> $ALL_SUBS_FILE"
}

# ---------------- LIVE HOSTS (dnsx) ----------------
COLLECT_LIVE(){
  mkdir -p "$COLLECTED_DIR"
  ALL_SUBS_FILE="$RAW_DIR/all_subdomains.out"
  if [[ ! -s "$ALL_SUBS_FILE" ]]; then
    ERR "No subdomains found to resolve"
    return
  fi
  RESOLVED_OUT="$COLLECTED_DIR/resolved.out"
  RUN_TOOL "dnsx" "$(command -v dnsx || echo \"$BIN_DIR/dnsx\")" -silent -l "$ALL_SUBS_FILE" -a -resp -o "$RESOLVED_OUT"
  OK "Resolved live hosts -> $RESOLVED_OUT"
  # create hosts list (unique hostnames)
  awk '{print $1}' "$RESOLVED_OUT" | sort -u > "$COLLECTED_DIR/hosts.txt" || true
}

# ---------------- PORT SCANNING (naabu then masscan sequentially) ----------------
PORT_SCAN_PER_HOST(){
  local HOST="$1"
  local HOST_SAFE
  HOST_SAFE=$(echo "$HOST" | sed -E 's/[:\/]/_/g')
  local PORTS_DIR="$COLLECTED_DIR/ports"
  mkdir -p "$PORTS_DIR"

  NAABU_OUT="$PORTS_DIR/${HOST_SAFE}_naabu.out"
  MASS_OUT="$PORTS_DIR/${HOST_SAFE}_masscan.out"

  INFO "Running naabu for $HOST"
  RUN_TOOL "naabu -> $HOST" "$(command -v naabu || echo \"$BIN_DIR/naabu\")" -host "$HOST" -ports 1-65535 -rate "$NAABU_RATE" -silent -o "$NAABU_OUT"

  INFO "Running masscan for $HOST"
  if command -v masscan >/dev/null 2>&1; then
    RUN_TOOL "masscan -> $HOST" "$(command -v masscan || echo \"$BIN_DIR/masscan\")" "$HOST" -p1-65535 --rate "$MASSCAN_RATE" -oG "$MASS_OUT"
  else
    INFO "masscan not installed, skipping masscan for $HOST"
  fi

  # aggregate ports from naabu and masscan -> hostname_ports (dedup)
  AGG="$PORTS_DIR/${HOST_SAFE}_agg.txt"
  > "$AGG"
  if [[ -f "$NAABU_OUT" ]]; then
    # naabu writes one port per line typically
    grep -oE '[0-9]{1,5}' "$NAABU_OUT" >> "$AGG" || true
  fi
  if [[ -f "$MASS_OUT" ]]; then
    grep -oE '[0-9]{1,5}' "$MASS_OUT" >> "$AGG" || true
  fi
  sort -n "$AGG" | awk '
    $1>=1 && $1<=65535 {print $1}
  ' | uniq > "$PORTS_DIR/${HOST_SAFE}_ports"
  OK "Ports for $HOST -> $PORTS_DIR/${HOST_SAFE}_ports"
}

# ---------------- SERVICE DETECTION (nmap using ports file) ----------------
SERVICE_DETECT_NMAP(){
  local HOST="$1"
  local HOST_SAFE
  HOST_SAFE=$(echo "$HOST" | sed -E 's/[:\/]/_/g')
  local PORTS_DIR="$COLLECTED_DIR/ports"
  local PORT_FILE="$PORTS_DIR/${HOST_SAFE}_ports"
  local NMAP_OUT="$PORTS_DIR/${HOST_SAFE}_nmap_services.nmap"

  if [[ ! -s "$PORT_FILE" ]]; then
    INFO "No ports file for $HOST; skipping nmap service detection"
    return
  fi

  # build comma-separated port list
  ports=$(paste -sd, "$PORT_FILE")
  if [[ -z "$ports" ]]; then
    INFO "No ports found for $HOST after aggregation; skipping nmap"
    return
  fi

  INFO "Running nmap -sV -T4 against $HOST ports: $ports"
  RUN_TOOL "nmap services -> $HOST" "$(command -v nmap || echo \"$BIN_DIR/nmap\")" -Pn -sV -T4 -p "$ports" -oN "$NMAP_OUT" "$HOST"
  OK "Nmap services saved -> $NMAP_OUT"
}

# ---------------- FFUF & NUCLEI (sequential per host) ----------------
RUN_FFUF_AND_NUCLEI_PER_HOST(){
  local HOST="$1"
  local HOST_SAFE
  HOST_SAFE=$(echo "$HOST" | sed -E 's/[:\/]/_/g')
  local FFUF_DIR="$COLLECTED_DIR/ffuf"
  local NUC_DIR="$COLLECTED_DIR/nuclei"
  mkdir -p "$FFUF_DIR" "$NUC_DIR"

  local WORDLIST
  WORDLIST=$(PICK_WORDLIST)
  [[ -z "$WORDLIST" ]] && { ERR "No ffuf wordlist found; skipping ffuf for $HOST"; return; }

  # root path scanning for both http and https
  for proto in http https; do
    OUT="$FFUF_DIR/${HOST_SAFE}_${proto}_root_ffuf.json"
    RUN_TOOL "ffuf ${proto} root -> $HOST" "$(command -v ffuf || echo \"$BIN_DIR/ffuf\")" -u "${proto}://$HOST/FUZZ" -w "$WORDLIST" -t "$FFUF_CONCURRENCY" -mc 200,301,302,307,401,403 -of json -o "$OUT"
  done

  # prepare nuclei targets file using host:port combos (http & https)
  NUC_TARGETS="$NUC_DIR/${HOST_SAFE}_targets.txt"
  > "$NUC_TARGETS"
  # use ports file to generate host:port combos
  PORT_FILE="$COLLECTED_DIR/ports/${HOST_SAFE}_ports"
  if [[ -s "$PORT_FILE" ]]; then
    while read -r P; do
      echo "http://${HOST}:${P}" >> "$NUC_TARGETS"
      echo "https://${HOST}:${P}" >> "$NUC_TARGETS"
    done < "$PORT_FILE"
  else
    echo "http://${HOST}" >> "$NUC_TARGETS"
    echo "https://${HOST}" >> "$NUC_TARGETS"
  fi

  if [[ -s "$NUC_TARGETS" ]]; then
    NUC_OUT="$NUC_DIR/${HOST_SAFE}.json"
    RUN_TOOL "nuclei -> $HOST" "$(command -v nuclei || echo \"$BIN_DIR/nuclei\")" -l "$NUC_TARGETS" -o "$NUC_OUT" -json
  fi
}

# ---------------- MAIN ----------------
BANNER

# ---------------- VALIDATE -f & RUN SUMMARY (with truncation) ----------------

# How many domains to show from a file before truncating
MAX_DISPLAY=25   # change this value if you want to show more/less

# If -f was provided, make sure file exists and is readable
if [[ -n "$INPUT_FILE" ]]; then
  if [[ ! -f "$INPUT_FILE" ]]; then
    BANNER
    ERR "File not found: $INPUT_FILE"
    USAGE
  fi
  if [[ ! -r "$INPUT_FILE" ]]; then
    BANNER
    ERR "File not readable: $INPUT_FILE"
    exit 1
  fi
fi

# Determine scan mode and prepare domain list if needed
if [[ -n "$INPUT_DOMAIN" ]]; then
  SCAN_MODE="Single Domain"
  TARGET_DESC="$INPUT_DOMAIN"
elif [[ -n "$INPUT_FILE" ]]; then
  SCAN_MODE="Domain List (from file)"
  # read domains into an array (preserve order, skip empty/comment lines)
  mapfile -t DOMAIN_LIST < <(awk 'NF && $1 !~ /^#/ {print $0}' "$INPUT_FILE")
  TOTAL_DOMAINS=${#DOMAIN_LIST[@]}
else
  SCAN_MODE="Unknown"
  TARGET_DESC="N/A"
fi

# Print summary (OUTPUT_DIR exists at this point)
echo -e "${BOLD}${CYAN}"
echo "─────────────────────────── SCOUT RUN SUMMARY ───────────────────────────"
echo -e "${RESET}${BOLD}Mode:${RESET} ${SCAN_MODE}"

if [[ -n "$INPUT_DOMAIN" ]]; then
  echo -e "${BOLD}Target:${RESET}           ${TARGET_DESC}"
elif [[ -n "$INPUT_FILE" ]]; then
  echo -e "${BOLD}Targets (from file):${RESET}"
  if (( TOTAL_DOMAINS == 0 )); then
    echo "  (no domains found in file)"
  else
    # determine how many lines to show
    if (( TOTAL_DOMAINS <= MAX_DISPLAY )); then
      SHOW_COUNT=$TOTAL_DOMAINS
    else
      SHOW_COUNT=$MAX_DISPLAY
    fi

    for ((i=0; i<SHOW_COUNT; i++)); do
      echo "  - ${DOMAIN_LIST[i]}"
    done

    if (( TOTAL_DOMAINS > SHOW_COUNT )); then
      REMAIN=$((TOTAL_DOMAINS - SHOW_COUNT))
      echo "  ... +${REMAIN} more"
    fi
  fi
else
  echo -e "${BOLD}Target(s):${RESET}        N/A"
fi

echo -e "${BOLD}Output Directory:${RESET} ${OUTPUT_DIR}"
echo -e "${BOLD}Tools Used:${RESET}"
cat <<'EOF'
  • Subdomain enumeration: subfinder, assetfinder, findomain, amass, gau, waybackurls
  • Live host discovery: dnsx
  • Port scanning: naabu, masscan
  • Service detection: nmap
  • Directory fuzzing: ffuf
  • Vulnerability scanning: nuclei
EOF
echo -e "${BOLD}${CYAN}──────────────────────────────────────────────────────────────────────────${RESET}\n"

# short pause so the user can read the summary before scanning begins
sleep 1

CHECK_ROOT
# ---------------- INPUT VALIDATION (NEW SECTION) ----------------
if [[ -z "$INPUT_DOMAIN" && -z "$INPUT_FILE" ]]; then
  ERR "Input not provided. Please specify a target with -d <domain> or -f <file>."
  USAGE
fi

if [[ -n "$INPUT_DOMAIN" && -n "$INPUT_FILE" ]]; then
  ERR "Cannot use -d and -f at the same time. Please choose one."
  USAGE
fi
INFO "Starting SCOUT"
INFO "Output directory: $OUTPUT_DIR"
CHECK_INTERNET
CHECK_BINS

# determine WILDCARDS input (already validated)
if [[ -n "$INPUT_DOMAIN" ]]; then
  # Create a temporary file in the output dir to hold the single domain
  WILDCARDS="$OUTPUT_DIR/target_domain.txt"
  echo "$INPUT_DOMAIN" > "$WILDCARDS"
elif [[ -n "$INPUT_FILE" ]]; then
  WILDCARDS="$INPUT_FILE"
fi

# per-domain pipeline (sequential)
while read -r DOMAIN; do
  DOMAIN=$(echo "$DOMAIN" | tr -d '[:space:]')
  [ -z "$DOMAIN" ] && continue

  DOMAIN_OUTPUT_DIR="$OUTPUT_DIR/${DOMAIN}"
  mkdir -p "$DOMAIN_OUTPUT_DIR"
  RAW_DIR="$DOMAIN_OUTPUT_DIR/raw"
  COLLECTED_DIR="$DOMAIN_OUTPUT_DIR/collected"
  mkdir -p "$RAW_DIR" "$COLLECTED_DIR"

  INFO "Starting domain for: $DOMAIN"

  # 1) enumeration
  COLLECT_SUBDOMAINS

  # 2) resolve live hosts from combined all_subdomains.out
  COLLECT_LIVE

  # hosts file
  HOSTS_FILE="$COLLECTED_DIR/hosts.txt"
  if [[ ! -s "$HOSTS_FILE" ]]; then
    ERR "No live hosts found for $DOMAIN; skipping host scans"
    continue
  fi

  # 3) per-host: naabu -> masscan -> aggregate ports -> nmap service detection -> ffuf -> nuclei
  while read -r H; do
    H=$(echo "$H" | tr -d '[:space:]')
    [ -z "$H" ] && continue
    INFO "Processing host: $H"
    PORT_SCAN_PER_HOST "$H"
    SERVICE_DETECT_NMAP "$H"
    RUN_FFUF_AND_NUCLEI_PER_HOST "$H"
  done < "$HOSTS_FILE"

  INFO "Domain $DOMAIN finished. Outputs under $DOMAIN_OUTPUT_DIR"

done < "$WILDCARDS"

INFO "All done. Outputs are in: $OUTPUT_DIR"
# EOF