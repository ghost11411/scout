#!/usr/bin/env bash
set -euo pipefail
IFS=$' \t\n'

# ---------------- COLORS ----------------
BLUE="\e[94m"; GREEN="\e[92m"; YELLOW="\e[93m"; RED="\e[91m"; RESET="\e[0m"; BOLD="\e[1m"; CYAN="\033[0;36m"; HIGH_GREEN="\e[38;5;82m"

# ---------------- LOGGING ----------------
OK()   { printf "${GREEN}[✓] %s${RESET}\n" "$1"; }
INFO() { printf "${BLUE}[*] %s${RESET}\n" "$1"; }
WARN() { printf "${YELLOW}[!] %s${RESET}\n" "$1"; }
ERR()  { printf "${RED}[X] %s${RESET}\n" "$1" >&2; }

# ---------------- DEFAULT PATHS & SETTINGS ----------------
VER="v0.1"
INSTALL_DIR="${HOME}/scout"
TOOLS_DIR="${INSTALL_DIR}/tools"
BIN_DIR="${TOOLS_DIR}/bin"
WORDLISTS_DIR="${TOOLS_DIR}/wordlists"
WORKSPACE_DIR="${INSTALL_DIR}/workspace"
FORCE=0
UPDATE=0
UNINSTALL=0

# ---------------- ARGS ----------------
INPUT_DOMAIN=""
INPUT_DOMAIN_FILE=""
INPUT_WILDCARD=""
INPUT_WILDCARD_FILE=""
CUSTOM_OUTPUT=""

# ---------------- BANNER ----------------
BANNER(){
  ASCII_SCOUT=$(cat <<'EOF'
    /$$$$$$   /$$$$$$   /$$$$$$  /$$   /$$ /$$$$$$$$
   /$$__  $$ /$$__  $$ /$$__  $$| $$  | $$|__  $$__/
  | $$  \__/| $$  \__/| $$  | $$| $$  | $$   | $$
  |  $$$$$$ | $$      | $$  | $$| $$  | $$   | $$
   \____  $$| $$      | $$  | $$| $$  | $$   | $$
   /$$  \ $$| $$    $$| $$  | $$| $$  | $$   | $$
  |  $$$$$$/|  $$$$$$/|  $$$$$$/|  $$$$$$/   | $$
   \______/  \______/  \______/  \______/    |__/
EOF
  )
  TAGLINE="Recon Made Easy                  Made By Ghost ${VER}"
  echo -e "${BOLD}${GREEN}=====================================================${RESET}"

  while IFS= read -r LINE; do
    for ((i=0;i<${#LINE};i++)); do
      printf "${HIGH_GREEN}${BOLD}%c${RESET}" "${LINE:i:1}"
      sleep 0.0005
    done
    printf "\n"
  done <<< "$ASCII_SCOUT"

  for ((i=0;i<${#TAGLINE};i++)); do
    printf "${CYAN}${BOLD}%c${RESET}" "${TAGLINE:i:1}"
    sleep 0.001
  done
  printf "\n"
  echo -e "${BOLD}${GREEN}=====================================================${RESET}"
}

# ---------------- REQUIRE ROOT ----------------
REQUIRE_ROOT() {
  if (( EUID != 0 )); then
    echo -e "${RED}[X] Root privileges required.${RESET}"
    echo -e "${YELLOW}[*] Re-running with sudo...${RESET}\n"
    exec sudo -E bash "$0" "$@"  # Preserve env and args
  fi
}

# ---------------- HELP ----------------
USAGE() {
  cat <<EOF
Usage: scout [options]
You can provide single or multiple comma-separated values for -dt and -wd:
  -dd   <domain1.com,domain2.com,...>        One or more domains
  -df   <file>                               File with one domain per line
  -wd   <*.domain1.com,*.domain2.com,...>    One or more wildcard domains
  -wf   <file>                               File with one wildcard per line

Optional:
  -o <dir>                                   Custom output directory (under $WORKSPACE_DIR)

Examples:
  scout -dd example.com
  scout -dd example.com -o <output_dir_name>
  scout -dd ex1.com,ex2.com -wd *.ex.com,*.ex2.com
  scout -wd *.example.com
  scout -df domains.txt
  scout -df domains.txt -wf wildcards.txt
  scout -df example.com -wf wildcards.txt -o <output_dir_name>

Flags:
  -h, --help         Show this help
  -v, --version      Show version information
  install [action]   Run installer (actions: update | force | uninstall)
EOF
  exit 0
}

BANNER
REQUIRE_ROOT "$@"

# ---------------- ARGUMENT PARSING ----------------
if [[ $# -eq 0 ]]; then
  ERR "No arguments provided."
  USAGE
fi

while [[ $# -gt 0 ]]; do
  case "$1" in
    -dd)
      [[ -z "${2:-}" || "${2:0:1}" == "-" ]] && { ERR "Option -dd requires argument(s)."; USAGE; }
      INPUT_DOMAIN="$2"; shift 2;;
    -df)
      [[ -z "${2:-}" || "${2:0:1}" == "-" ]] && { ERR "Option -df requires a file path."; USAGE; }
      INPUT_DOMAIN_FILE="$2"; shift 2;;
    -wd)
      [[ -z "${2:-}" || "${2:0:1}" == "-" ]] && { ERR "Option -wd requires argument(s)."; USAGE; }
      INPUT_WILDCARD="$2"; shift 2;;
    -wf)
      [[ -z "${2:-}" || "${2:0:1}" == "-" ]] && { ERR "Option -wf requires a file path."; USAGE; }
      INPUT_WILDCARD_FILE="$2"; shift 2;;
    -o)
      [[ -z "${2:-}" || "${2:0:1}" == "-" ]] && { ERR "Option -o requires a directory name."; USAGE; }
      CUSTOM_OUTPUT="$2"; shift 2;;
    install)
        CONFIGURE="${INSTALL_DIR}/configure"
        [[ ! -f "$CONFIGURE" ]] && CONFIGURE="./configure"

        ACTION="${2:-}"

        case "$ACTION" in
            --force)
                INFO "Running forced reinstallation..."
                bash "$CONFIGURE" --force
                exit 0
                ;;
            --update)
                INFO "Running update..."
                bash "$CONFIGURE" --update
                exit 0
                ;;
            --uninstall)
                INFO "Running uninstallation..."
                bash "$CONFIGURE" --uninstall
                exit 0
                ;;
            *)
                INFO "Running default installation..."
                bash "$CONFIGURE"
                exit 0
                ;;
        esac
        ;;

    -h|--help) USAGE ;;
    -v|--version)
      echo -e "${BOLD}Version:${RESET} ${VER}"
      exit 0;;
    *)
      ERR "Unknown option: $1"
      USAGE;;
  esac
done

# ---------------- OUTPUT DIR ----------------
CURRENTDATE=$(date +"%Y-%m-%d_%H-%M-%S")
if [[ -n "$CUSTOM_OUTPUT" ]]; then
  SANITIZED_OUTPUT=$(echo "$CUSTOM_OUTPUT" | tr -cd '[:alnum:]_-')
  OUTPUT_DIR="$WORKSPACE_DIR/$SANITIZED_OUTPUT"
else
  OUTPUT_DIR="$WORKSPACE_DIR/output_$CURRENTDATE"
fi
mkdir -p "$OUTPUT_DIR"

# ---------------- SPINNER & CLEANUP ----------------
CLEANUP() {
  if [[ -n "${SPINNER_PID:-}" ]]; then
    kill "$SPINNER_PID" 2>/dev/null || true
  fi
  echo -ne "\r\033[K"
}
trap CLEANUP SIGINT SIGTERM EXIT

START_SPINNER() {
  processing="$1"
  SPIN_START=$(date +%s)
  BRAILLE=("⠋" "⠙" "⠹" "⠸" "⠼" "⠴" "⠦" "⠧" "⠇" "⠏")
  while true; do
    ELAPSED=$(( $(date +%s) - SPIN_START ))
    for char in "${BRAILLE[@]}"; do
      printf "\r${YELLOW}[${char}]${RESET} ${processing} ${CYAN}(${ELAPSED}s)${RESET}"
      sleep 0.07
    done
  done &
  SPINNER_PID=$!
}

STOP_SPINNER() {
  if [[ -n "${SPINNER_PID:-}" ]]; then
    kill "$SPINNER_PID" 2>/dev/null || true
    wait "$SPINNER_PID" 2>/dev/null || true
    echo -ne "\r\033[K"
  fi
}

# ---------------- BASIC CHECKS ----------------
CHECK_INTERNET(){
  INFO "Checking internet connectivity..."
  if ! curl -fsS --head https://www.google.com >/dev/null 2>&1; then
    if ! ping -c1 1.1.1.1 >/dev/null 2>&1; then
      ERR "No Internet connection detected."; exit 1
    fi
  fi
  OK "Online"
}

CHECK_BINS(){
  REQUIRED=(subfinder assetfinder findomain gau waybackurls amass httpx unfurl dnsx ffuf nuclei naabu)
  MISSING=()
  for b in "${REQUIRED[@]}"; do
    if ! command -v "$b" >/dev/null 2>&1 && [[ ! -x "$BIN_DIR/$b" ]]; then
      MISSING+=("$b")
    fi
  done
  if (( ${#MISSING[@]} > 0 )); then
    ERR "Missing tools: ${MISSING[*]}"
    exit 1
  fi
  OK "All required tools found"
}

# ---------------- INPUT VALIDATION ----------------
if [[ -z "$INPUT_DOMAIN" && -z "$INPUT_DOMAIN_FILE" && -z "$INPUT_WILDCARD" && -z "$INPUT_WILDCARD_FILE" ]]; then
  ERR "No input provided. Use -dd, -df, -wd, -wf."
  USAGE
fi

# ---------------- BUILD TARGETS ----------------
if [[ -n "${INPUT_DOMAIN:-}" || -n "${INPUT_DOMAIN_FILE:-}" ]]; then
    INPUT_DOMAIN_ALL_FILE="$OUTPUT_DIR/domains_all.txt"
    : > "$INPUT_DOMAIN_ALL_FILE"

    [[ -n "${INPUT_DOMAIN:-}" ]] &&
        IFS=',' read -ra arr <<< "$INPUT_DOMAIN" &&
        printf "%s\n" "${arr[@]}" | sed 's/^[ \t]*//;s/[ \t]*$//' >> "$INPUT_DOMAIN_ALL_FILE"

    [[ -n "${INPUT_DOMAIN_FILE:-}" ]] &&
        awk 'NF && $1 !~ /^#/' "$INPUT_DOMAIN_FILE" >> "$INPUT_DOMAIN_ALL_FILE"

    sort -u "$INPUT_DOMAIN_ALL_FILE" -o "$INPUT_DOMAIN_ALL_FILE"
fi

if [[ -n "${INPUT_WILDCARD:-}" || -n "${INPUT_WILDCARD_FILE:-}" ]]; then
    INPUT_WILDCARD_ALL_FILE="$OUTPUT_DIR/wildcards_all.txt"
    : > "$INPUT_WILDCARD_ALL_FILE"

    [[ -n "${INPUT_WILDCARD:-}" ]] &&
        IFS=',' read -ra arr <<< "$INPUT_WILDCARD" &&
        printf "%s\n" "${arr[@]}" | sed 's/^[ \t]*//;s/[ \t]*$//' >> "$INPUT_WILDCARD_ALL_FILE"

    [[ -n "${INPUT_WILDCARD_FILE:-}" ]] &&
        awk 'NF && $1 !~ /^#/' "$INPUT_WILDCARD_FILE" >> "$INPUT_WILDCARD_ALL_FILE"

    sort -u "$INPUT_WILDCARD_ALL_FILE" -o "$INPUT_WILDCARD_ALL_FILE"
fi

_trim(){ local v="$*"; v="${v#"${v%%[![:space:]]*}"}"; v="${v%"${v##*[![:space:]]}"}"; printf '%s' "$v"; }

# ---------------- SUMMARY ----------------
echo -e "${BOLD}${CYAN}─────────────────────────── SCOUT RUN SUMMARY ───────────────────────────${RESET}"
INFO "Input Domain: ${INPUT_DOMAIN:-None}"
INFO "Input Domain File: ${INPUT_DOMAIN_FILE:-None}"
INFO "Input Wildcards: ${INPUT_WILDCARD:-None}"
INFO "Input Wildcards File: ${INPUT_WILDCARD_FILE:-None}"
echo -e ""
if [[ -s "$OUTPUT_DIR/domains_all.txt" ]]; then
  INFO "Domains to scan from -dd/-df: $(wc -l < "$INPUT_DOMAIN_ALL_FILE" || echo 0)"
  INFO "Total unique domains to scan: $(wc -l < "$INPUT_DOMAIN_ALL_FILE" | awk '{s+=$1} END {print s}' || echo 0)"
else 
  INFO "No domains to scan from -dd/-df."
fi
echo -e ""

if [[ -s "$OUTPUT_DIR/wildcards_all.txt" ]]; then
  INFO "Wildcards to scan from -wd/-wf: $(wc -l < "$INPUT_WILDCARD_ALL_FILE" || echo 0)"
  INFO "Total unique wildcards to scan: $(wc -l < "$INPUT_WILDCARD_ALL_FILE" | awk '{s+=$1} END {print s}' || echo 0)"
else 
  INFO "No wildcard domains to scan from -wd/-wf."
fi
echo -e "${RESET}"

INFO "Output Directory: $OUTPUT_DIR"
echo -e ""
echo -e "${BOLD}Tools Used:${RESET}"
cat <<'EOF'
  • Subdomain enumeration: subfinder, assetfinder, findomain, subdog, xsubfind3r, cero, crt.sh, sublist3r
  • Live host discovery: dnsx, puredns, httpx
  • Port scanning: naabu
  • Service detection: nmap
  • Directory fuzzing: ffuf
  • Vulnerability scanning: nuclei
EOF
echo -e "${BOLD}${CYAN}──────────────────────────────────────────────────────────────────────────${RESET}\n"

# ---------------- LOAD EXTERNAL COMMANDS ----------------
CMDS_DIR="${INSTALL_DIR}"/cmd

SOURCE_CMD() {
  local func="$1"
  local script="${CMDS_DIR}/${func}"
  if [[ -f "$script" ]]; then
    source "$script"
    OK "Loaded ${script}"
  else
    WARN "Missing ${script} — using fallback stub."
    eval "${func}(){ INFO \"${func}: not implemented (stub)\"; }"
  fi
}
SOURCE_CMD "collect_subdomains"
SOURCE_CMD "collect_live"
# SOURCE_CMD "collect_js"
# SOURCE_CMD "port_scan"
# SOURCE_CMD "service_scan"
# SOURCE_CMD "nuclei_scan"
export INSTALL_DIR TOOLS_DIR BIN_DIR WORDLISTS_DIR WORKSPACE_DIR INPUT_DOMAIN_ALL_FILE INPUT_WILDCARD_ALL_FILE OUTPUT_DIR

# ---------------- MAIN EXECUTION ----------------
INFO "Starting Scout"
CHECK_INTERNET
CHECK_BINS || true
echo -e "${BOLD}${CYAN}──────────────────────────────────────────────────────────────────────────${RESET}\n"
if [[ -s "$INPUT_WILDCARD_ALL_FILE" ]]; then
  COLLECT_SUBDOMAINS
fi
ALL_SUBS_FILE="$COLLECTED_DIR/all_subdomains.out"
echo -e "${BOLD}${CYAN}──────────────────────────────────────────────────────────────────────────${RESET}\n"
COLLECT_LIVE
RESOLVED_OUT="$COLLECTED_DIR/puredns_resolved.out"
echo -e "${BOLD}${CYAN}─────────────────────────── FINALIZING RESULTS ───────────────────────────${RESET}\n"
# Combine all subdomains into final_subdomains.out
cat "$RESOLVED_OUT" "$INPUT_DOMAIN_ALL_FILE" | sort -u > "$COLLECTED_DIR/final_subdomains.out" 2>/dev/null || true
COUNT=$(wc -l < "$COLLECTED_DIR/final_subdomains.out" || echo 0)
INFO "Total unique subdomains collected: $COUNT" 
INFO "Final combined subdomains saved to: $COLLECTED_DIR/final_subdomains.out" 
echo -e "${BOLD}${CYAN}──────────────────────────────────────────────────────────────────────────${RESET}\n"
INFO "Scout run completed."