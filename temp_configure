#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'

# Unified configure/installer/uninstaller for Scout
# Combines functionality from: configure, modules/installer, modules/uninstaller

# ---------------- Colors ----------------
BLUE="\e[94m"; GREEN="\e[92m"; YELLOW="\e[93m"; RED="\e[91m"; RESET="\e[0m"; BOLD="\e[1m"; CYAN="\033[0;36m"; HIGH_GREEN="\e[38;5;82m";
VER=v0.1

# ---------------- Defaults & Paths ----------------
REPO_URL="https://github.com/ghost11411/scout"
INSTALL_DIR="${HOME}/scout"
FORCE=false
UPDATE=false
UNINSTALL=false
ASSUME_YES=false
DRY_RUN=false
LOG_FILE="/tmp/scout_temp_configure.log"
: > "$LOG_FILE"

# Installer-specific paths (will be used when running install actions)
TOOLS_DIR="${INSTALL_DIR}/tools"
BIN_DIR="${TOOLS_DIR}/bin"
WORDLISTS_DIR="${INSTALL_DIR}/wordlists"
GF_DIR="$WORDLISTS_DIR/GF-Patterns"

# ---------------- ASCII BANNER ----------------
BANNER(){
  ASCII_SCOUT=$(cat <<'EOF'
    /$$$$$$   /$$$$$$   /$$$$$$  /$$   /$$ /$$$$$$$$
   /$$__  $$ /$$__  $$ /$$__  $$| $$  | $$|__  $$__/
  | $$  \__/| $$  \__/| $$  \ $$| $$  | $$   | $$   
  |  $$$$$$ | $$      | $$  | $$| $$  | $$   | $$   
   \____  $$| $$      | $$  | $$| $$  | $$   | $$   
   /$$  \ $$| $$    $$| $$  | $$| $$  | $$   | $$   
  |  $$$$$$/|  $$$$$$/|  $$$$$$/|  $$$$$$/   | $$   
   \______/  \______/  \______/  \______/    |__/   
EOF
  )
  local tag="${VER:-v?}"
  TAGLINE="Recon Made Easy                  Made By Ghost ${tag}"

  echo -e "${BOLD}${GREEN}=====================================================${RESET}"
  echo -e "${HIGH_GREEN}${BOLD}${ASCII_SCOUT}${RESET}"
  echo -e "${CYAN}${BOLD}${TAGLINE}${RESET}"
  echo -e "${BOLD}${GREEN}=====================================================${RESET}"
}

OK()      { printf "${GREEN}[✔] %s${RESET}\n" "$1"; }
INFO()    { printf "${BLUE}[*] %s${RESET}\n" "$1"; }
WARN()    { printf "${YELLOW}[!] %s${RESET}\n" "$1"; }
ERR()     { printf "${RED}[✘] %s${RESET}\n" "$1" >> "$LOG_FILE"; }

# Prompt for confirmation (returns 0 if yes)
prompt_confirm() {
	local msg=${1:-"Are you sure?"}
	local ans
	if [ "${ASSUME_YES:-false}" = true ]; then
		INFO "Assuming yes to prompt: $msg"
		return 0
	fi
	read -r -p "$msg [y/N]: " ans
	case "${ans,,}" in
		y|yes) return 0 ;;
		*) return 1 ;;
	esac
}

# ---------------- Parse Arguments ----------------
for arg in "$@"; do
	case "$arg" in
	    --force) FORCE=true ;;
	    --update) UPDATE=true ;;
	    --uninstall) UNINSTALL=true ;;
	--yes|-y) ASSUME_YES=true ;;
	--dry-run) DRY_RUN=true ;;
	    --help|-h)
			cat <<EOF
Usage: temp_configure [--force] [--update] [--uninstall] [--yes]
Actions:
	--force     Remove any existing installation and perform a fresh install
	--update    Update an existing git installation
	--uninstall Remove the installation and symlink
	--yes, -y   Answer yes to any prompts (non-interactive)
	--dry-run   Simulate actions without running commands
	--help      Show this help
EOF
			exit 0
			;;
		*)
			ERR "Unknown option: $arg"
			echo "Usage: temp_configure [--force | --update | --uninstall]"
			exit 1
			;;
	esac
done

# ---------------- Start ----------------
BANNER
INFO "Starting Scout configure script..."

# ---------------- CHECK ROOT ----------------
if [ "$EUID" -ne 0 ]; then
  ERR "Please run as root (sudo ./temp_configure)"
  exit 1
fi

# ---------------- Uninstall flow ----------------
if [ "$UNINSTALL" = true ]; then
	INFO "Running uninstaller flow..."
	if [ ! -d "$INSTALL_DIR" ]; then
	  ERR "Scout is not installed in $INSTALL_DIR"
	  exit 1
	fi

	if ! prompt_confirm "This will remove '$INSTALL_DIR' and the scout symlink. Proceed?"; then
		INFO "Uninstall cancelled by user"
		exit 0
	fi

	INFO "Removing $INSTALL_DIR..."
	if rm -rf -- "$INSTALL_DIR"; then
		OK "Removed $INSTALL_DIR"
	else
		ERR "Failed to remove $INSTALL_DIR"
		exit 1
	fi

	if [ -L /usr/local/bin/scout ]; then
		if rm -f -- /usr/local/bin/scout 2>/dev/null; then
			OK "Removed /usr/local/bin/scout"
		elif sudo rm -f -- /usr/local/bin/scout 2>/dev/null; then
			OK "Removed /usr/local/bin/scout (via sudo)"
		else
			ERR "Could not remove /usr/local/bin/scout (permission required). Run: sudo rm -f /usr/local/bin/scout"
		fi
	else
		OK "No symlink /usr/local/bin/scout found"
	fi

	OK "Scout uninstalled. Folder removed: '$INSTALL_DIR'"
	exit 0
fi

# ---------------- Handle Flags & Git clone/update ----------------
if [ "$FORCE" = true ] && [ "$UPDATE" = true ]; then
	ERR "--force and --update cannot be used together."
	exit 1
fi

if [ "$FORCE" = true ]; then
	WARN "--force flag detected..."
	if [ -d "$INSTALL_DIR" ]; then
		if ! prompt_confirm "This will remove existing installation at '$INSTALL_DIR'. Proceed?"; then
			INFO "Force install cancelled by user"
			exit 0
		fi
		INFO "Removing existing installation at $INSTALL_DIR..."
		if rm -rf -- "$INSTALL_DIR"; then
			OK "Removed $INSTALL_DIR"
		else
			ERR "Failed to remove $INSTALL_DIR"
			exit 1
		fi
	fi

	INFO "Cloning fresh repository..."
	if RUN_CMD "git clone $REPO_URL" git clone "$REPO_URL" "$INSTALL_DIR"; then
		:
	else
		ERR "Failed to clone repository. Check your network connection."
		exit 1
	fi

elif [ "$UPDATE" = true ]; then
	WARN "--update flag detected..."
	if [ -d "$INSTALL_DIR/.git" ]; then
		cd "$INSTALL_DIR" || exit 1
		INFO "Updating existing repository..."
	RUN_CMD "git reset --hard" git reset --hard || true
	RUN_CMD "git pull --rebase" git pull --rebase --autostash || true
		OK "Updated repository at $INSTALL_DIR"
	elif [ -d "$INSTALL_DIR" ] && [ ! -d "$INSTALL_DIR/.git" ] ; then
		ERR "Directory $INSTALL_DIR exists but is not a Git repository. Use --force to reinstall."
		exit 1
	else
		ERR "No existing installation found. Use --force to perform a fresh install."
		exit 1
	fi

else
	WARN "No flags detected, proceeding with default behavior..."
	if [ -d "$INSTALL_DIR" ]; then
		if [ -d "$INSTALL_DIR/.git" ]; then
			ERR "Installation directory $INSTALL_DIR already exists. Use --update to update or --force to reinstall."
		else
			ERR "Directory $INSTALL_DIR exists but is not a Git repository. Use --force to reinstall."
		fi
		exit 1
	fi

	INFO "Cloning repository to '$INSTALL_DIR'..."
	if RUN_CMD "git clone $REPO_URL" git clone "$REPO_URL" "$INSTALL_DIR"; then
		:
	else
		ERR "Failed to clone repository. Check your network connection."
		exit 1
	fi
	OK "Cloned repository to $INSTALL_DIR"
fi

# ---------------- Shared permissions & installer execution ----------------
INFO "Setting executable permissions for scripts..."
find "$INSTALL_DIR" -type f -exec chmod +x {} \; || {
	ERR "Failed to set permissions. Check your permissions."
	exit 1
}

INFO "Preparing to run Installer actions..."

# ---------------- Installer functions (merged and deduplicated) ----------------
# shellcheck disable=SC2317
RUN_CMD() {
	local DESC="$1"
	shift
	if [ "${DRY_RUN:-false}" = true ]; then
		INFO "DRY-RUN: would run: $* -- ($DESC)"
		return 0
	fi
	if "$@" >>"$LOG_FILE" 2>&1; then
		OK "$DESC"
		return 0
	else
		ERR "$DESC failed. Check $LOG_FILE"
		return 1
	fi
}

CHECK_COMMAND() { command -v "$1" >/dev/null 2>&1; }

GO_TOOLS=(
	"mapcidr|github.com/projectdiscovery/mapcidr/cmd/mapcidr@latest"
	"amass|github.com/owasp-amass/amass/v4/...@master"
	"assetfinder|github.com/tomnomnom/assetfinder@latest"
	"subfinder|github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest"
	"waybackurls|github.com/tomnomnom/waybackurls@latest"
	"gau|github.com/lc/gau/v2/cmd/gau@latest"
	"dnsx|github.com/projectdiscovery/dnsx/cmd/dnsx@latest"
	"gf|github.com/tomnomnom/gf@latest"
	"unfurl|github.com/tomnomnom/unfurl@latest"
	"httprobe|github.com/tomnomnom/httprobe@latest"
	"httpx|github.com/projectdiscovery/httpx/cmd/httpx@latest"
	"ffuf|github.com/ffuf/ffuf/v2@latest"
	"nuclei|github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest"
	"naabu|github.com/projectdiscovery/naabu/v2/cmd/naabu@latest"
	"notify|github.com/projectdiscovery/notify/cmd/notify@latest"
)

APT_PACKAGES=(
	coreutils git whois jq unzip python3 python3-pip python3-requests python3-dnspython pipx parallel gcc curl wget zip cewl python3-shodan make ca-certificates libpcap-dev golang-go
)

PIPX_TOOLS=("arjun")

REPOS=(
	"GF-Patterns|$GF_DIR|https://github.com/1ndianl33t/GF-Patterns.git"
	"Sublist3r|$TOOLS_DIR/Sublist3r|https://github.com/aboul3la/Sublist3r.git"
)

# ENSURE_BASIC_COMMANDS() {
# 	local OKAY=0
# 	local MISSING=()
# 	for CMD in git curl jq tar unzip go bash; do
# 		if ! CHECK_COMMAND "$CMD"; then
# 			MISSING+=("$CMD")
# 			OKAY=1
# 		fi
# 	done
# 	if [ ${#MISSING[@]} -ne 0 ]; then
# 		WARN "Missing basic commands: ${MISSING[*]}"
# 	fi
# 	[ "$OKAY" -eq 0 ]
# }

INSTALL_APT_PACKAGES() {
	INFO "Updating apt cache (non-interactive)..."
	export DEBIAN_FRONTEND=noninteractive
	if RUN_CMD "apt update" apt-get update -y -qq; then
		:
	else
		WARN "apt update returned a non-zero exit code; continuing"
	fi

	INFO "Installing apt packages (may take several minutes)..."
	if RUN_CMD "apt install packages" apt-get install -y -qq --no-install-recommends "${APT_PACKAGES[@]}"; then
		OK "apt packages installed"
	else
		WARN "apt install had issues; check $LOG_FILE"
	fi
}

INSTALL_PIPX_TOOLS() {
	# Ensure local bin path is present so pipx/pip --user install locations are usable
	export PATH="$HOME/.local/bin:$BIN_DIR:$PATH"
	mkdir -p "$BIN_DIR" 2>/dev/null || true

	if ! CHECK_COMMAND pipx; then
		INFO "Installing pipx (bootstrap via pip)"
		if RUN_CMD "pip install pipx" python3 -m pip install --user pipx; then
			RUN_CMD "pipx ensurepath" python3 -m pipx ensurepath || true
		else
			WARN "Failed to install pipx via pip; pipx will be unavailable and fallback to pip --user will be used"
		fi
	else
		INFO "pipx already available"
	fi

	for T in "${PIPX_TOOLS[@]}"; do
		if CHECK_COMMAND pipx; then
			if pipx list 2>/dev/null | grep -qE "^\s*${T}"; then
				INFO "$T already installed via pipx"
				continue
			fi
			RUN_CMD "pipx install $T" pipx install "$T" || WARN "pipx install failed for $T"
		else
			# fallback to pip --user
			if RUN_CMD "pip install $T" python3 -m pip install --user "$T"; then
				:
			else
				WARN "Failed to install $T via pip"
			fi
		fi
	done
}

INSTALL_GO_TOOLS_ONE_BY_ONE() {
	if ! CHECK_COMMAND go; then
		WARN "Go not found; skipping Go tools"
		return
	fi
	mkdir -p "$BIN_DIR" 2>/dev/null || true
	export GOBIN="$BIN_DIR"
	export GOPATH="${GOPATH:-$HOME/go}"
	export PATH="$GOBIN:$HOME/.local/bin:$PATH"

	INFO "Installing Go tools into $GOBIN"
	for PAIR in "${GO_TOOLS[@]}"; do
		NAME="${PAIR%%|*}"
		PKG="${PAIR#*|}"
		if RUN_CMD "go install $NAME" env GOBIN="$GOBIN" go install "$PKG"; then
			OK "$NAME"
		else
			WARN "$NAME failed to install; check $LOG_FILE"
		fi
	done
}

INSTALL_MASSCAN() {
	if [ -x "$BIN_DIR/masscan" ]; then
		INFO "masscan already present"
		return
	fi
	local DIR
	DIR=$(mktemp -d)
	if ! RUN_CMD "git clone masscan" git clone --depth 1 https://github.com/robertdavidgraham/masscan.git "$DIR"; then
		return 1
	fi
	if ! RUN_CMD "make masscan" make -C "$DIR" -j"$(nproc)"; then
		return 1
	fi
	if [ -f "$DIR/bin/masscan" ]; then
		mv "$DIR/bin/masscan" "$BIN_DIR/"
		chmod +x "$BIN_DIR/masscan"
		OK "masscan"
	else
		ERR "masscan build failed"
	fi
	if [ -n "${DIR:-}" ]; then
		rm -rf -- "$DIR" 2>/dev/null || true
	fi
}

INSTALL_NMAP() {
	if [ -x "$BIN_DIR/nmap" ]; then
		INFO "nmap already installed"
		return
	fi
	local URL="https://github.com/andrew-d/static-binaries/raw/master/binaries/linux/x86_64/nmap"
	INFO "Installing nmap"
	if RUN_CMD "fetch nmap" curl -fsSL "$URL" -o "$BIN_DIR/nmap"; then
		chmod +x "$BIN_DIR/nmap" || true
	else
		WARN "Failed to fetch nmap"
	fi
}

INSTALL_FINDOMAIN() {
	if [ -x "$BIN_DIR/findomain" ]; then
		INFO "findomain already installed"
		return
	fi
	INFO "Installing findomain"
	local VER TMP
	VER=$(curl -fsSL https://github.com/Findomain/Findomain/releases/latest 2>>"$LOG_FILE" | grep -Eo 'tag/[0-9A-Za-z._-]+' | head -n1 | cut -d'/' -f2 || true)
	[ -z "$VER" ] && { WARN "Could not determine findomain latest version"; return; }
	TMP=$(mktemp -d)
	RUN_CMD "download findomain" curl -fsSL -L "https://github.com/Findomain/Findomain/releases/download/$VER/findomain-linux.zip" -o "$TMP/findomain.zip" || true
	RUN_CMD "unzip findomain" unzip -o "$TMP/findomain.zip" -d "$TMP" || true
	if [ -f "$TMP/findomain" ]; then
		mv "$TMP/findomain" "$BIN_DIR/findomain"
		chmod +x "$BIN_DIR/findomain"
		OK "findomain"
	else
		WARN "findomain binary not found"
	fi
	if [ -n "${TMP:-}" ]; then
		rm -rf -- "$TMP" 2>/dev/null || true
	fi
}

CLONE_OR_UPDATE_REPOS() {
	for ENTRY in "${REPOS[@]}"; do
		IFS='|' read -r NAME PATH GITURL <<< "$ENTRY"
		if [ -d "$PATH/.git" ]; then
			INFO "Updating $NAME..."
			RUN_CMD "git pull $NAME" git -C "$PATH" pull --rebase --autostash || true
			OK "$NAME updated"
		elif [ -d "$PATH" ]; then
			WARN "Directory $PATH exists but is not a git repo; skipping $NAME"
		else
			INFO "Cloning $NAME into $PATH..."
			if RUN_CMD "git clone $NAME" git clone "$GITURL" "$PATH"; then
				:
			else
				WARN "Failed to clone $NAME"
			fi
		fi
	done
}

UPDATE_NUCLEI_TEMPLATES() {
	if [ -x "$BIN_DIR/nuclei" ]; then
		if RUN_CMD "nuclei -ut" "$BIN_DIR/nuclei" -ut; then
			OK "Nuclei templates updated"
		else
			WARN "Nuclei template update failed"
		fi
	else
		WARN "nuclei not found; skip templates update"
	fi
}

# ---------------- Run installer sequence ----------------
INFO "Starting full install sequence"
INSTALL_APT_PACKAGES || true
# ENSURE_BASIC_COMMANDS || true
INSTALL_PIPX_TOOLS || true
INSTALL_GO_TOOLS_ONE_BY_ONE || true
INSTALL_MASSCAN || true
INSTALL_NMAP || true
INSTALL_FINDOMAIN || true
CLONE_OR_UPDATE_REPOS || true
UPDATE_NUCLEI_TEMPLATES || true

if [ -n "${BIN_DIR:-}" ]; then
	chmod 755 -- "$BIN_DIR"/* 2>/dev/null || true
fi
if [ -f "$INSTALL_DIR/scout" ]; then
	chmod +x -- "$INSTALL_DIR/scout" || true
fi
if [ -w /usr/local/bin ]; then
	ln -sf "$INSTALL_DIR/scout" /usr/local/bin/scout && OK "Symlink created"
elif sudo -n true 2>/dev/null; then
	sudo ln -sf "$INSTALL_DIR/scout" /usr/local/bin/scout && OK "Symlink created (sudo)"
else
	WARN "Could not symlink; run manually: sudo ln -sf $INSTALL_DIR/scout /usr/local/bin/scout"
fi

OK "Install finished"
echo -e "Type ${BOLD}${CYAN}scout${RESET} to get started."
echo -e "For help, type ${BOLD}${CYAN}scout --help${RESET} or visit the GitHub repository: ${BOLD}${CYAN}${REPO_URL}${RESET}"

if [ -s "$LOG_FILE" ]; then
	echo
	echo "Last 40 lines from installer log ($LOG_FILE):"
	tail -n 40 "$LOG_FILE" || true
fi

OK "Happy Recon! 🔎"
exit 0

